[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Análise de dados com R",
    "section": "",
    "text": "Introdução\nEste é um livro de introdução à análise de dados com R, voltado para cientistas sociais. O livro aborda o funcionamento da linguagem de programação R e do software de desenvolvimento RStudio/Posit, visando oferecer noções gerais e operações básicas para o domínio e a autonomia na análise de dados. O livro envolve desde a história sobre a origem dessa linguagem e dos softwares a operações fundamentais de importação, manuseio, análise, visualização, exportação e comunicação de dados. Uma referência importante é o livro  R for Data Science (1). Por seguir o livro de referência, os tópicos mesclam com o inglês para estimular a adaptação ao software, à comunidade de programadores internacionais e aos manuais, que têm a língua inglesa como padrão.\nA proposta é que seja um livro também de instruções, do gênero “mão na massa”. Para o bom funcionamento das aulas, portanto, é importante acompanhar o conteúdo e praticar executando os códigos de exemplo, fazendo os tutoriais e os exercícios. O livro é como um guia, mas recomendo que explorem o funcionamento desta ferramenta para ir conquistando o domínio.",
    "crumbs": [
      "Introdução"
    ]
  },
  {
    "objectID": "index.html#download-e-instalação",
    "href": "index.html#download-e-instalação",
    "title": "Análise de dados com R",
    "section": "Download e instalação",
    "text": "Download e instalação\nO primeiro passo é baixar os softwares R e seu auxiliar RStudio/Posit, que serve como ambiente de desenvolvimento.",
    "crumbs": [
      "Introdução"
    ]
  },
  {
    "objectID": "index.html#download-e-instalação-r-e-rstudio",
    "href": "index.html#download-e-instalação-r-e-rstudio",
    "title": "Análise de dados com R",
    "section": "Download e instalação R e RStudio",
    "text": "Download e instalação R e RStudio\nO primeiro passo é baixar os softwares R e seu auxiliar RStudio/Posit, que serve como ambiente de desenvolvimento.",
    "crumbs": [
      "Introdução"
    ]
  },
  {
    "objectID": "index.html#instruções-para-o-google-colab",
    "href": "index.html#instruções-para-o-google-colab",
    "title": "Análise de dados com R",
    "section": "Instruções para o Google Colab",
    "text": "Instruções para o Google Colab\nUma alternativa aos softwares de Desktop é o ambiente de desenvolvimento da Google, o Google Colaboratory. Veremos sobre o uso deste recurso em aula.\n\n\n\n\n[1] WICKHAM, H.; GROLEMUND, G.; ÇETINKAYA-RUNDEL, M. R for Data Science. 2. ed. [s.l.] O’Reilly, 2024.",
    "crumbs": [
      "Introdução"
    ]
  },
  {
    "objectID": "class01.html",
    "href": "class01.html",
    "title": "Capítulo 1",
    "section": "",
    "text": "É de comer?\nO R é uma linguagem de programação, o que significa que podemos utilizá-la para nos comunicar com o computador. Isto é, seguimos a sintaxe da linguagem para usar comandos que orientam o computador a executar operações. Uma definição mais específica do R é a de linguagem voltada a objetos. Isso porque o R fuciona muito direcionado às informações guardadas como objetos na memória.\nComo uma linguagem, o R tem uma sintaxe e para dominá-la precisamos praticar. Por isso este livro é mesclado entre explicações e exemplos práticos. Não é pavê, nem pacumê. É pa praticar!",
    "crumbs": [
      "Capítulo 1"
    ]
  },
  {
    "objectID": "class01.html#é-de-comer",
    "href": "class01.html#é-de-comer",
    "title": "Capítulo 1",
    "section": "",
    "text": "Mas… por que o R e não outro?\nO que torna o R especial para a pesquisa é ter sido desenvolvido para fins estatísticos, que ao longo do tempo tomou a forma de Ciência de Dados. Os autores da linguagem são os estatísticos Ross Ihaka (neozelandês) e Robert Gentleman (canadense). Eles iniciaram o projeto em meados dos anos 1990, tendo circulado a primeira cópia do arquivo binário, embrião do R, em uma lista de e-mails de pesquisadores que trabalhavam com a linguagem S, chamada s-news.\nCom a circulação do projeto, Ross e Robert receberam uma indicação de Martin Mächler, professor no Departamento de Matemática da Universidade de Zurique (Suiça), para associarem o software ao projeto GNU, de desenvolvimento de softwares livres. Os autores acataram a ideia e em junho de 1995 estava disponível o código fonte do R sob licença da GNU Free Software Foundation. Essa história foi contada no artigo R: A Language for Data Analysis and Graphics (1), onde os autores apresentaram o projeto publicamente para a comunidade acadêmica. Depois disso o projeto ganhou adesão e força. No ano seguinte, em 1997, foi fundado o R Core Group, composto por pessoas responsáveis pelo controle da versão do código fonte, que atualmente gere o Comprehensive R Archive Network (CRAN), onde são registradas e distribuídas as atualizações do R. A versão 1.0 do R foi divulgada em 2002 e passou por diversas atualizações até chegar a atual 4.4.1.\nAté 2009, o R era usado por estatísticos, cientistas da computação e pesquisadores engajados com este tipo de expertise. O cenário mudou com o desenvolvimento de um ambiente integrado de trabalho, o RStudio, que facilitou o fluxo. Além disso, em 2016, o então cientista chefe da empresa RStudio, Hadley Wickham, em colaboração com Garrett Grolemund, concretizou o projeto Tidy Data (2), visando aprimorar o manuseio de dados, publicando um conjunto de funções em pacotes voltados para a análise de dados, todos integrados ao Tidyverse. O projeto foi costruído por quatro princípios: 1. reutilização de estrutura de dados existentes; 2. composição de funções simples com o pipe; 3. incetivar programação que seja funcional e; 4. códigos que seja interpretáveis para humanos. Por enquanto estamos conhecendo a história, mas a transformação que isso causou será percebida quando começarmos a utilizar o pacote tidyverse.\n\n\n\n\nIt is often said that 80% of data analysis is spent on the process of cleaning and preparing the data (Dasu and Johnson 2003). Data preparation is not just a first step, but must be repeated many times over the course of analysis as new problems come to light or new data is collected. Despite the amount of time it takes, there has been surprisingly little research on how to clean data well. Part of the challenge is the breadth of activities it encompasses: from outlier checking, to date parsing, to missing value imputation. To get a handle on the problem, this paper focuses on a small, but important, aspect of data cleaning that I call data tidying: structuring datasets to facilitate analysis. (2 p. 1)\n\n\n\n\nPerceba que toda a história do R foi construída na contramão dos softwares de mercado, como o Statistical Package for Social Sciences (SPSS), produto da IBM, e o Pacote Office, produto da Microsoft. Trata-se de um projeto conduzido por pesquisas acadêmicas de ponta, visando facilitar o trabalho com a análise de dados. Trabalhar com o R, portanto, implica em um outro paradigma. Ao invés de ter o software como um produto administrado por uma empresa, onde as funções já estão programadas e disponíveis por botões e comandos, temos uma linguagem a partir da qual podemos programar funções e executar comandos diversos. Há diversas implicações nessa mudança que transformaram completamente o trabalho com dados nas Ciências Sociais, permitindo maior abertura para a criatividade e replicabilidade. Todo o nosso fluxo de trabalho é escrito em um documento, que pode ser compartilhado com outras pessoas, que podem verificar o passo-a-passo e replicar. Além disso, a forma como utilizamos o software possibilita eficiência nos processamentos, com baixo custo de tempo e recursos de hardware. Veremos isso ao longo o curso.\n\n\nO uso de linguagem de programação nas Ciências Sociais\nDados e metodologias são os principais elementos para o trabalho com pesquisa e operacionalização de teorias. Em geral, formulamos hipóteses sobre o mundo informadas por literaturas específicas, e testamos essas hipóteses coletando dados e utilizando metodologias. As linguagens de programação nos ajudam na parte operacional de tratamento e análise dos dados.\nSer parte do Projeto GNU de softwares livres é o primeiro ponto forte do R. Além disso, podemos destacar outros pontos importantes do R, como:\n\nEficiência: o fluxo de trabalho com funções reduz o custo de memória e processamento.\n\n\n\nPotência: não estamos mais limitados às funções programadas no software, como é vendido. Podemos programar funções novas e fazer (quase) tudo com R. Excel e SPSS estão anos atrás!\nReplicabilidade e transparência: os procedimentos são registrados em código, portando mais transparentes e possíveis de serem replicados. Práticas fundamentais e cada vez mais impulsionadas por revistas e instituições acadêmicas.\nPopularidade: movido por uma comunidade internacional extensa, que desenvolve e acompanha o software. Cada vez mais adotado em instituições (principalmente públicas) e pela comunidade acadêmica.\n\nO manuseio e a análise de dados é um desafio de longa data. Do ponto de vista do armazenamento e processamento, a principal pesquisa nacional, o Censo Demográfico, já era um desafio desde, pelo menos, 1960 (ver 3). Uma área que emergiu diante desses desafios é a de Ciências Sociais Computacionais, que aborda desde o desenvolvimento de algoritmos para a extração e análise de dados até a discussão teórica sobre ambientes digitais.\nAinda que a programação esteja relacionada com lógica e cálculo, não se trata apenas de informações quantitativas. Podemos tratar, além dos famosos surveys, também dados não estruturados, textos, imagens, sons e tudo o mais que puder ser registrado. Tudo isso torna mais atraente a análise de dados com uso de programação.\nSe você é uma pessoa curiosa e que quer explorar a criatividade, a sofisticação e a elegância em seu trabalho, está no lugar certo.",
    "crumbs": [
      "Capítulo 1"
    ]
  },
  {
    "objectID": "class01.html#mas-por-que-o-r-e-não-outro",
    "href": "class01.html#mas-por-que-o-r-e-não-outro",
    "title": "Capítulo 1",
    "section": "Mas… por que o R e não outro?",
    "text": "Mas… por que o R e não outro?\nO que torna o R especial para a pesquisa é ter sido desenvolvido para fins estatísticos, que ao longo do tempo tomou a forma de análise de dados. Os autores da linguagem são os estatísticos Ross Ihaka (neozelandês) e Robert Gentleman (canadense). Eles iniciaram o projeto em meados dos anos 1990, tendo circulado a primeira cópia do arquivo binário, embrião do R, em uma lista de e-mails de pesquisadores que trabalhavam com a linguagem S, chamada s-news.\nCom a circulação do projeto, Ross e Robert receberam uma indicação de Martin Mächler, professor no Departamento de Matemática da Universidade de Zurique (Suiça), para associarem o software ao projeto GNU, de desenvolvimento de softwares livres. Os autores acataram a ideia e em junho de 1995 estava disponível o código fonte do R sob licença da GNU Free Software Foundation. Essa história foi contada no artigo R: A Language for Data Analysis and Graphics (1996), onde os autores apresentaram o projeto publicamente para a comunidade acadêmica. Depois disso o projeto ganhou adesão e força. No ano seguinte, em 1997, foi fundado o R Core Group, composto por pessoas responsáveis pelo controle da versão do código fonte, que atualmente gere o Comprehensive R Archive Network (CRAN), onde são registradas e distribuídas as atualizações do R. A versão 1.0 do R foi divulgada em 2002 e passou por diversas atualizações até chegar a atual 4.4.1.\nAté 2009, o R era usado por estatísticos, cientistas da computação e pesquisadores engajados com este tipo de expertise. O cenário mudou com o desenvolvimento de um ambiente integrado de trabalho, o RStudio, que facilitou o fluxo. Além disso, em 2016, o então cientista chefe da empresa RStudio, Hadley Wickham, em colaboração com Garrett Grolemund, concretizou o projeto Tidy Data, visando aprimorar o manuseio de dados, publicando um conjunto de funções em pacotes voltados para a análise de dados, todos integrados ao Tidyverse. O projeto foi costruído por quatro princípios: 1. reutilização de estrutura de dados existentes; 2. composição de funções simples com o pipe; 3. incetivar programação que seja funcional e; 4. códigos que seja interpretáveis para humanos. Por enquanto estamos conhecendo a história, mas a transformação que isso causou será percebida quando começarmos a utilizar o pacote tidyverse.\nPerceba que toda a história do R foi construída na contramão dos softwares de mercado, como o SPSS da IBM e o pacote office da Microsoft. Trata-se de um projeto conduzido por pesquisas acadêmicas de ponta, visando facilitar o trabalho com a análise de dados. Trabalhar com o R, portanto, implica em um outro paradigma. Ao invés de ter o software como um produto administrado por uma empresa, onde as funções já estão programadas e disponíveis por botões e comandos, temos uma linguagem a partir da qual podemos programar funções e executar comandos diversos. Há diversas implicações nessa mudança que transformaram completamente o trabalho com dados nas Ciências Sociais, permitindo maior abertura para a criatividade e replicabilidade. Todo o nosso fluxo de trabalho é escrito em um documento, que pode ser compartilhado com outras pessoas, que podem verificar o passo-a-passo e replicar. Além disso, a forma como utilizamos o software possibilita eficiência nos processamentos, com baixo custo de tempo e recursos de hardware. Veremos isso ao longo o curso.",
    "crumbs": [
      "Capítulo 1"
    ]
  },
  {
    "objectID": "class01.html#ok.-entendi.-então-como-eu-uso",
    "href": "class01.html#ok.-entendi.-então-como-eu-uso",
    "title": "Capítulo 1",
    "section": "Ok. Entendi. Então como eu uso?",
    "text": "Ok. Entendi. Então como eu uso?\nComo vimos, o R é pa praticar! Então, ferramentas em mãos.\nÉ fudamental saber que o R é a linguagem, e o RStudio é o ambiente de desenvolvimento. Não adianta tentar usar o RStudio sem o R. Portato, faça a instalação do R e RStudio de acordo com as especificações do seu computador.\nComo uma experiência antropológica e de choque , abra o R (não o RStudio!). Caso tenha dificuldade em econtrar o software, digite na busca do seu computador apenas a letra “R” e procure em aplicativos.\nVocê deve abrir algo parecido com essa janela.\n\n\n\nConsole R\n\n\nA janela onde escrevemos as linhas de comandos executáveis chamamos de “console”. Abrindo o R diretamente, temos apenas a janela do console para inserir os comandos. Triste, né? Mas tudo fica mais sexy com o RStudio. Para fins didáticos, vamos continuar com o R base. Precisamos olhar um pouco para o console como faziam os egípcios e os hebreus.\nNeste livro, por ser escrito no R, temos as linhas de comando destacadas, que podem ser copiadas e coladas no console para executar.",
    "crumbs": [
      "Capítulo 1"
    ]
  },
  {
    "objectID": "class01.html#primeiro-contato-r-como-calculadora",
    "href": "class01.html#primeiro-contato-r-como-calculadora",
    "title": "Capítulo 1",
    "section": "Primeiro contato: R como calculadora",
    "text": "Primeiro contato: R como calculadora\nExecutar cálculos simples com o R é uma forma mais amigável de começar entender como a linguagem funciona. Podemos pensar no computador como uma grande calculadora que computa operações e, no R, como um meio para comandar o computador.\nPor exemplo, no comando abaixo, eu computo um cálculo simples no R e, em seguida, recebo um resultado. Faça o mesmo no console do R base. Digite 1+2 e dê um enter para computar\n\n1+2\n\n[1] 3\n\n\nLegal, não é? Talvez não ainda. Mas vai ficar!\nAlém de números e cálculos, podemos executar outros tipos de informações como caracteres (texto) e valores lógicos (Verdadeiro e Falso). Para caracteres, devemos sempre utilizar aspas simples ou duplas, conforme a linha abaixo.\n\n\"Utilize sempre aspas para informações textuais\"\n\n[1] \"Utilize sempre aspas para informações textuais\"\n\n\nPara valores lógicos, usamos o inglês TRUE e FALSE, que podem ser abreviados pelas iniciais T e F, conforme a linha abaixo.\n\nTRUE\n\n[1] TRUE\n\nFALSE\n\n[1] FALSE\n\nT\n\n[1] TRUE\n\nF\n\n[1] FALSE\n\n\nCom o tempo, vamos escrevendo códigos (scripts) que compilam um conjunto sequencial de comandos. Os códigos vão ficando cada vez mais complexos na medida em que vamos trabalhando. Um recurso muito importante para torná-los interpretáveis para humanos são os comentários. Para que o R não interprete uma linha de um documento como um comando, devemos marcá-la com “#”. Toda informação que vem depois de um “#”, na linha, é descosiderada pelo R.\n\n# Este comentário não é executado. Simples assim.\n\nComo exercício, escreva um comentário e execute no console do R base. Depois escreva o mesmo sem a marcação de comentário.\nVocê vai perceber que, sem indicar que e um comentário (#), o R tenta computar os valores e retorna erro, porque não consegue identificar nada associado.\nEm geral, números, caracteres, valores lógicos e comentários compõem a base fundamental da linguagem R.\nVamos fazer um exercício didático para introduzir o uso de códigos. Copie as linhas de comando abaixo e cole na janela console, no R base. Você pode ir colando linha a linha e executado os comandos para observar o que acontece.\n\n# Primeiro código com o R\n# Autor: Victor G Alcantara\n\n# R como calculadora\n\n## Fazedo cálculos simples\n1+2\n\n3+5*4\n\n10/2\n\n## Computando texto\n\"Trabalhar com programação é desafiador\"\n\n## Computado valores lógicos\nTRUE\n\nFALSE\n\nUma vez compreedendo as bases, podemos operá-las utilizando a memória do computador.\nPara guardar valores na memória, como objetos, utilizamos os sinais se atribuição “&lt;-” e “=”.\n\nSinais de atribuição de valores à memória:\n\nSeta: objeto &lt;- valor\nUm igual: objeto = valor\n\n\n\nresultado &lt;- 1+2\n\nresultado\n\n[1] 3\n\n\nNo exemplo acima, guardamos o cálculo 1+2 no objeto “resultado”, armazenado na memória. Perceba que estamos interpretando a linha de código. O que o R interpreta é o mesmo. Podemos ler como: atribua ao objeto “resultado” o valor da conta 1+2.\nUma vez guardado na memória, podemos nos referir ao objeto para acessar o valor, conforme ilustra o exemplo abaixo.\n\nresultado + 1\n\n[1] 4\n\n\nPara guardar mais de um valor em um objeto, devemos utilizar uma função para concatenar os valores, expressa por um “c” seguido de parêteses e os valores contidos.\n\nvalores_num &lt;- c(1,2,3,4,5)\n\nvalores_num\n\n[1] 1 2 3 4 5\n\n\nPodemos fazer operações com todos os valores guardados em um objeto. Por definição, chamamos um objeto que contenha apenas um tipo ou classe de valores como um vetor. Podemos dizer, assim, que criamos um vetor guardado no objeto “valores_num” que recebe os valores de 1 a 5.\nPodemos fazer operações com nosso vetor, como no exemplo abaixo.\n\n1 + valores_num\n\n[1] 2 3 4 5 6\n\n\nToda vez que nos referirmos ao nome do objeto guardado, sem o uso de aspas, o R vai entender que estamos nos referindo a todos os valores guardados no vetor. Por isso a soma 1 + vetor tem como resultado todos os valores + 1.\nPara acessar um valor específico em um vetor, podemos indicar a localização do valor utilizando colchetes [ ].\nvetor[ posição do valor ]\n\nvalores_num[3] # Obtendo o valor guardado na posição 3\n\n[1] 3\n\n\nUm vetor guarda sempre um tipo ou classe de valores. Podemos fazer operações que sejam adequadas a cada tipo de valor contido. Por exemplo, para vetores que guardam textos, não podemos fazer cálculos (o R retornará como erro).\n\nvalores_chr &lt;- c(\"A\",\"B\",\"C\",\"D\",\"E\")\nvalores_chr\n\n[1] \"A\" \"B\" \"C\" \"D\" \"E\"\n\nvalores_chr[1] # Obtendo o valor guardado na posição 1\n\n[1] \"A\"\n\nvalores_chr[3] # Obtendo o valor guardado na posição 3\n\n[1] \"C\"\n\n\n\nvalores_chr + 1\n\nError in valores_chr + 1: argumento não-numérico para operador binário\n\n\nNão se assuste com a mensagem de erro. Ela sempre aparecerá com alguma explicação que te ajudará a entender. Neste caso, ele está dizendo que o argumento não é um valor numérico para fazer cálculo. Às vezes, o R retornará também mensagens de aviso (Warnings).\nNunca se esqueça de que o R é burro e o inteligente é você. No caminho, vão surgir muitos erros que vão te fazer pensar o contrário.\nAté aqui vimos o suficiente do R base. Agora, precisamos do RStudio para avança de uma forma mais atrativa.\nAbra o RStudio no seu computador.\nVocê deve abrir algo parecido com a imagem abaixo. Uma das inovações deste ambiente de trabalho é dividir o fluxo em quatro janelas. A primeira, geralmente localizada no quadrante 1) script; 2) console; 3) gestão de aquivos e outputs e; 4) ambiente global (gestão de memória).\n\n\n\nRStudio Layout\n\n\n\n\n\nEditor de Scripts: Essa janela é sua amiga da organização! É onde você escreve e salva seu código em arquivos. Em vez de rodar cada comando diretamente, você pode escrever vários comandos e depois executá-los da forma que quiser, selecionando partes ou tudo, quando estiver pronto.\n\n\n\n\nConsole: É onde a mágica acontece! É a mesma janela que abrimos no R base. Aqui você executa comandos e vê os resultados imediatamente. Pense nele como uma “calculadora” poderosa: basta digitar o código, apertar Enter, e o R responde!\n\n\n\n\nFiles/Plots/Packages/Help: Essa janela multifuncional é super versátil! No Files, você navega nos arquivos do projeto; em Plots, visualiza gráficos; em Packages, gerencia as bibliotecas instaladas; e em Help, encontra ajuda para funções e pacotes. É um verdadeiro canivete suíço para explorar recursos e referências do R!\n\n\n\n\nAmbiente/Histórico: Aqui fica o “quadro de controle” dos seus dados e variáveis. No Ambiente, você vê todas as variáveis e dados carregados na sessão, enquanto o Histórico mostra os comandos que você já executou. Se você quiser repetir ou ajustar um comando anterior, é só buscá-lo aqui.\n\n\n\nAgora, com o RStudio, registraremos nossos códigos no editor de script. Perceba que podemos criar diversos tipos de arquivos para edição. O RStudio comporta, inclusive, arquivos para serem executados em outras linguagens, como Python, C++ e SQL.\nSeguindo a sintaxe da linguagem e as funções disponíveis, escrevemos nossos códigos no editor de script. Em nosso curso, veremos comandos e funções importantes para importação, tratamento, manuseio e análise de dados. Mas para um bom domínio da ferramenta, é importante entendermos como ela opera.\n\nComandos lógicos\n\n\nComandos relacionais\n\n\nFunções\nPodemos também usar funções, que são comandos programados para executar determinados procedimentos. Por exemplo, a função “sum” faz a soma de um conjunto de valores, como o “=SOMA( )” no Excel.\n\nsum(1,2)\n\n[1] 3\n\n\nVocê já está, intuitivamente, percebendo que a estrutura das funções no R é dada pelo nome da função (ex. “sum”), seguido de atributos inseridos dentro de parênteses “( atributos aqui )”. Nem todas as funções exigem atributos, mas todas as funções executam algum procedimento. Por exemplo, temos um conjunto de funções muito úteis para limpar a memória local (o que ajuda no processamento) e obter o diretório (pasta) principal onde estamos trabalhando.\n\ngc( ) : de “Garbage Clean”, para limpeza da lixeira e liberação de memória.\ngetwd( ) : de “Get Working Directory”, para obter diretório base no qual está trabalhando.\n\n\ngc()\n\n          used (Mb) gc trigger (Mb) max used (Mb)\nNcells  599260 32.1    1360200 72.7  1360200 72.7\nVcells 1104816  8.5    8388608 64.0  1876245 14.4\n\ngetwd()\n\n[1] \"C:/Users/13477365/Documents/book-dadoscomr\"",
    "crumbs": [
      "Capítulo 1"
    ]
  },
  {
    "objectID": "class01.html#o-uso-de-linguagem-de-programação-nas-ciências-sociais",
    "href": "class01.html#o-uso-de-linguagem-de-programação-nas-ciências-sociais",
    "title": "Capítulo 1",
    "section": "O uso de linguagem de programação nas Ciências Sociais",
    "text": "O uso de linguagem de programação nas Ciências Sociais\nDados e metodologias são os principais elementos para o trabalho com pesquisa e operacionalização de teorias. Em geral, formulamos hipóteses sobre o mundo informadas por literaturas específicas, e testamos essas hipóteses coletando dados e utilizando metodologias. As linguagens de programação nos ajudam na parte operacional de tratamento e análise dos dados.\nNos últimos anos, estamos experimentando uma mudança no paradigma de análise de dados nas Ciências Sociais. Ao invés do consumo de softwares com funções estatísticas programadas, disponíveis no mercado, como o Statistical Package for Social Sciences (SPSS), produto da IBM, e o Pacote Office, produto da Microsoft, estamos migrando para linguagens de programação de acesso livre e gratuito.\nSer parte do Projeto GNU de softwares livres é o primeiro ponto forte do R. Com as demais linguagens de programação, porém, há também pontos impotantes, como:\n\nEficiência: o fluxo de trabalho com funções reduz o custo de memória e processamento.\n\n\n\nPotência: não estamos mais limitados às funções programadas no software, como é vendido. Podemos programar funções novas e fazer (quase) tudo com R. Excel e SPSS estão anos atrás!\nReplicabilidade e transparência: os procedimentos são registrados em código, portando mais transparentes e possíveis de serem replicados. Práticas fundamentais e cada vez mais impulsionadas por revistas e instituições acadêmicas.\nPopularidade: movido por uma comunidade internacional extensa, que desenvolve e acompanha o software. Cada vez mais adotado em instituições (principalmente públicas) e pela comunidade acadêmica.\n\nO manuseio e a análise de dados é um desafio de longa data. Do ponto de vista do armazenamento e processamento, a principal pesquisa nacional, o Censo Demográfico, já era um desafio desde, pelo menos, 1960 (para saber mais sobre a história dos censos).\nUma área que emergiu diante desses desafios é a de Ciências Sociais Computacionais, que aborda desde o desenvolvimento de algoritmos para a extração e análise de dados até a discussão teórica sobre ambientes digitais.\nAinda que a programação esteja relacionada com lógica e cálculo, não se trata apenas de informações quantitativas. Podemos tratar, além dos famosos surveys, também dados não estruturados, textos, imagens, sons e tudo o mais que puder ser registrado. Tudo isso torna mais atraente a análise de dados com uso de programação.\nSe você é uma pessoa curiosa e que quer explorar a criatividade, a sofisticação e a elegância em seu trabalho, está no lugar certo.",
    "crumbs": [
      "Capítulo 1"
    ]
  },
  {
    "objectID": "class02.html",
    "href": "class02.html",
    "title": "Capítulo 2",
    "section": "",
    "text": "Funções: uma ideia mais detalhada\nVimos que funções são operações programadas, que são executadas recebendo (ou não) argumentos de input e retornando algum resultado do processamento (output). As funções são estruturadas por um nome, seguido de parênteses dentro dos quais entram os argumentos de input.\nHá um conjunto de funções básicas que já vem com o R e podem ser utilizadas, como a função “ifelse”.\n# teste = 1 é maior do que 3? \n# Se sim, retorne \"Verdade\", se não, \"Mentira\" \nifelse( test = 1&gt;3, \n        yes = \"Verdade\", \n        no =\"Mentira\" ) \n\n[1] \"Mentira\"\nUsando a sintaxe do R, podemos também programar uma função. Para isso, usamos a seguinte estrutura de comandos:\nnome_da_funcao &lt;- function( input ) { algum processamento do input }\n# Criando uma função\nx_mais_1 &lt;- function( x ) { x + 1 }\nObserve que a função criada aparece na memória como um objeto do tipo “function”, na janela de ambiente global. Agora, podemos utilizar a função criada.\n# Utilizando a função criada\nx_mais_1(x = 2)\n\n[1] 3\nEste é um exemplo didático. Em geral, as funções executam operações complexas e servem para facilitar o nosso código. Veja o exemplo abaixo:\nfrase_exemplo &lt;- function( x, y ) { \n  paste(\"Meu nome é\",x,\"e tenho\",y,\"anos\")  }\n\n# a função \"paste\" cola textos com valores guardados em objetos\n\nfrase_exemplo(x = \"Victor\",y = 26)\n\n[1] \"Meu nome é Victor e tenho 26 anos\"\nAlém das funções básicas do R, temos muitas outras que foram programadas pela comunidade de usuários, entre as quais aquelas desenvolvidas por Hadley Wickham para análise de dados com R. As funções programadas são agrupadas em pacotes, que são disponibilizados pelo CRAN ou em plataformas de desenvolvedores, como o GitHub. Os pacotes no CRAN passam por inspeção do grupo de controle e podem ser instalados diretos pelo R. Já os pacotes em outras plataformas podem ser instalados usando funções específicas.\nPara usar os pacotes, temos primeiro que instalar em nosso computador local, usando a função install.packages( ).\nPrecisamos fazer a instalação apenas uma vez. Quando feita, teremos o pacote salvo em nosso computador, em uma pasta dentro dos arquivos do R. Sempre que precisarmos do pacote em um código, porém, devemos carregá-lo na memória, usando a função library( ).\nAgora, podemos instalar e carregar na memória o pacote mais famoso do R: o tidyverse. Logo começaremos a usá-lo.\n# install.packages(\"tidyverse\")\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\nA instalação e carregamento de pacotes sempre deve ser feita no início do script, compondo a parte de setup. Como os comandos são executados conforme a ordem em que aparecem no script, devemos começar com o setup do nosso ambiente de trabalho. Embora seja possível executar muitas operações com os botões disponibilizados pelo RStudio, é mais eficiente executá-las com comandos. No próximo tópico, veremos operações de rotina para a organização do ambiente de trabalho.",
    "crumbs": [
      "Capítulo 2"
    ]
  },
  {
    "objectID": "class01.html#entendi-o-que-é.-então-como-eu-uso",
    "href": "class01.html#entendi-o-que-é.-então-como-eu-uso",
    "title": "Capítulo 1",
    "section": "Entendi o que é. Então como eu uso?",
    "text": "Entendi o que é. Então como eu uso?\nComo vimos, o R é pa praticar! Então, ferramentas em mãos.\nÉ fudamental saber que o R é a linguagem, e o RStudio é o ambiente de desenvolvimento. Não adianta tentar usar o RStudio sem o R. Portato, faça a instalação do R e RStudio de acordo com as especificações do seu computador.\nComo uma experiência antropológica e de choque , abra o R (não o RStudio!). Caso tenha dificuldade em econtrar o software, digite na busca do seu computador apenas a letra “R” e procure em aplicativos.\nVocê deve abrir algo parecido com essa janela.\n\n\n\nConsole R\n\n\nA janela onde escrevemos as linhas de comandos executáveis chamamos de “console”. Abrindo o R diretamente, temos apenas a janela do console para inserir os comandos. Triste, né? Mas tudo fica mais sexy com o RStudio. Para fins didáticos, vamos continuar com o R base. Precisamos olhar um pouco para o console como faziam os egípcios e os hebreus.\nNeste livro, por ser escrito no R, temos as linhas de comando destacadas, que podem ser copiadas e coladas no console para executar.\n\nPrimeiro contato: R como calculadora\nExecutar cálculos simples com o R é uma forma mais amigável de começar entender como a linguagem funciona. Podemos pensar no computador como uma grande calculadora que computa operações e, no R, como um meio para comandar o computador.\nPor exemplo, no comando abaixo, eu computo um cálculo simples no R e, em seguida, recebo um resultado. Faça o mesmo no console do R base. Digite 1+2 e dê um enter para computar\n\n1+2\n\n[1] 3\n\n\nLegal, não é? Talvez não ainda. Mas vai ficar!\nAlém de números e cálculos, podemos executar outros tipos de informações como caracteres (texto) e valores lógicos (Verdadeiro e Falso). Para caracteres, devemos sempre utilizar aspas simples ou duplas, conforme a linha abaixo.\n\n\"Utilize sempre aspas para informações textuais\"\n\n[1] \"Utilize sempre aspas para informações textuais\"\n\n\nPara valores lógicos, usamos o inglês TRUE e FALSE, que podem ser abreviados pelas iniciais T e F, conforme a linha abaixo.\n\nTRUE\n\n[1] TRUE\n\nFALSE\n\n[1] FALSE\n\nT\n\n[1] TRUE\n\nF\n\n[1] FALSE\n\n\nCom o tempo, vamos escrevendo códigos (scripts) que compilam um conjunto sequencial de comandos. Os códigos vão ficando cada vez mais complexos na medida em que vamos trabalhando. Um recurso muito importante para torná-los interpretáveis para humanos são os comentários. Para que o R não interprete uma linha de um documento como um comando, devemos marcá-la com “#”. Toda informação que vem depois de um “#”, na linha, é descosiderada pelo R.\n\n# Este comentário não é executado. Simples assim.\n\nComo exercício, escreva um comentário e execute no console do R base. Depois escreva o mesmo sem a marcação de comentário.\nVocê vai perceber que, sem indicar que e um comentário (#), o R tenta computar os valores e retorna erro, porque não consegue identificar nada associado.\nEm geral, números, caracteres, valores lógicos e comentários compõem a base fundamental da linguagem R.\nVamos fazer um exercício didático para introduzir o uso de códigos. Copie as linhas de comando abaixo e cole na janela console, no R base. Você pode ir colando linha a linha e executado os comandos para observar o que acontece.\n\n# Primeiro código com o R\n# Autor: Victor G Alcantara\n\n# R como calculadora\n\n## Fazedo cálculos simples\n1+2\n\n3+5*4\n\n10/2\n\n## Computando texto\n\"Trabalhar com programação é desafiador\"\n\n## Computado valores lógicos\nTRUE\n\nFALSE\n\nUma vez compreedendo as bases, podemos operá-las utilizando a memória do computador.\nPara guardar valores na memória, como objetos, utilizamos os sinais se atribuição “&lt;-” e “=”.\n\nSinais de atribuição de valores à memória:\n\nSeta: objeto &lt;- valor\nUm igual: objeto = valor\n\n\n\nresultado &lt;- 1+2\n\nresultado\n\n[1] 3\n\n\nNo exemplo acima, guardamos o cálculo 1+2 no objeto “resultado”, armazenado na memória. Perceba que estamos interpretando a linha de código. O que o R interpreta é o mesmo. Podemos ler como: atribua ao objeto “resultado” o valor da conta 1+2.\nUma vez guardado na memória, podemos nos referir ao objeto para acessar o valor, conforme ilustra o exemplo abaixo.\n\nresultado + 1\n\n[1] 4\n\n\nPara guardar mais de um valor em um objeto, devemos utilizar uma função para concatenar os valores, expressa por um “c” seguido de parêteses e os valores contidos, separados por vírgula.\n\nvalores_num &lt;- c(1,2,3,4,5)\n\nvalores_num\n\n[1] 1 2 3 4 5\n\n\nPodemos fazer operações com todos os valores guardados em um objeto. Por definição, chamamos um objeto que contenha apenas um tipo ou classe de valores como um vetor. Podemos dizer, assim, que criamos um vetor guardado no objeto “valores_num” que recebe os valores de 1 a 5.\nPodemos fazer operações com nosso vetor, como no exemplo abaixo.\n\n1 + valores_num\n\n[1] 2 3 4 5 6\n\n\nToda vez que nos referirmos ao nome do objeto guardado, sem o uso de aspas, o R vai entender que estamos nos referindo a todos os valores guardados no vetor. Por isso a soma 1 + vetor tem como resultado todos os valores + 1.\nPara acessar um valor específico em um vetor, podemos indicar a localização do valor utilizando colchetes [ ].\nvetor[ posição do valor ]\n\nvalores_num[3] # Obtendo o valor guardado na posição 3\n\n[1] 3\n\n\nUm vetor guarda sempre um tipo ou classe de valores. Podemos fazer operações que sejam adequadas a cada tipo de valor contido. Por exemplo, para vetores que guardam textos, não podemos fazer cálculos (o R retornará como erro).\n\nvalores_chr &lt;- c(\"A\",\"B\",\"C\",\"D\",\"E\")\nvalores_chr\n\n[1] \"A\" \"B\" \"C\" \"D\" \"E\"\n\nvalores_chr[1] # Obtendo o valor guardado na posição 1\n\n[1] \"A\"\n\nvalores_chr[3] # Obtendo o valor guardado na posição 3\n\n[1] \"C\"\n\n\n\nvalores_chr + 1\n\nError in valores_chr + 1: argumento não-numérico para operador binário\n\n\nNão se assuste com a mensagem de erro. Ela sempre aparecerá com alguma explicação que te ajudará a entender. Neste caso, ele está dizendo que o argumento não é um valor numérico para fazer cálculo. O R se esforça para ser nosso amigo e muitas vezes, quando notar que pode ter algo errado, vai nos avisar com Warning.\nEmbora tente ser nosso amigo, nunca se esqueça de que o R é burro e o inteligente é você. No caminho, vão surgir muitos erros que vão te fazer pensar o contrário. Mas todos têm solução.\nAté aqui vimos o suficiente do R base. Agora, precisamos do RStudio para avança de uma forma mais atrativa.\n\n\nExplorado comandos com RStudio\nAbra o RStudio no seu computador.\nVocê deve abrir algo parecido com a imagem abaixo. Uma das inovações deste ambiente de trabalho é dividir o fluxo em quatro janelas. A primeira, geralmente localizada no quadrante 1) script; 2) console; 3) gestão de aquivos e outputs e; 4) ambiente global (gestão de memória).\n\n\n\nRStudio Layout\n\n\n\n\n\nEditor de Scripts: Essa janela é sua amiga da organização! É onde você escreve e salva seu código em arquivos. Em vez de rodar cada comando diretamente, você pode escrever vários comandos e depois executá-los da forma que quiser, selecionando partes ou tudo, quando estiver pronto.\n\n\n\n\nConsole: É onde a mágica acontece! É a mesma janela que abrimos no R base. Aqui você executa comandos e vê os resultados imediatamente. Pense nele como uma “calculadora” poderosa: basta digitar o código, apertar Enter, e o R responde!\n\n\n\n\nFiles/Plots/Packages/Help: Essa janela multifuncional é super versátil. No Files, você navega nos arquivos do projeto; em Plots, visualiza gráficos; em Packages, gerencia as bibliotecas instaladas; e em Help, encontra ajuda para funções e pacotes. É um verdadeiro canivete suíço para explorar recursos e referências do R!\n\n\n\n\nAmbiente/Histórico: Aqui fica o “quadro de controle” dos seus dados e variáveis. No Ambiente, você vê todas as variáveis e dados carregados na sessão, enquanto o Histórico mostra os comandos que você já executou. Se você quiser repetir ou ajustar um comando anterior, é só buscá-lo aqui.\n\n\n\nAgora, com o RStudio, registraremos nossos códigos no editor de script. Perceba que podemos criar diversos tipos de arquivos para edição. O RStudio comporta, inclusive, arquivos para serem executados em outras linguagens, como Python, C++ e SQL.\nSeguindo a sintaxe da linguagem e as funções disponíveis, escrevemos nossos códigos no editor de script. Em nosso curso, veremos comandos e funções importantes para importação, tratamento, manuseio e análise de dados. Mas para um bom domínio da ferramenta, é importante entendermos como ela opera.\nPor convenção, seguimos padrões de escrita do código, que chamamos de identação. A identação auxilia a deixar o código organizado e interpretável para humanos. Mesmo os softwares de desenvolvimento, como o RStudio, são capazes de interpretar padrões de identação. Por exemplo, quando iserimos um comentário com “#” e finalizamos com traços “—-”, o RStudio entende que se trata de um título para um segmento do código. Veremos como fazer isso mais pra frente.\nEm geral, orgaizamos os códigos seguindo a lógica do fluxo de trabalho. Que pode ser descrito por:\n\nSetup e configurações básicas\nArmazenamento\nManuseio\nAnálise\nExportação dos resultados\n\nAgora, vamos retomar os fundamentos da linguagem R em um script organizado usando o RStudio.\n\n\nFunções\nAlém dos comandos básicos, podemos também usar funções, que são comandos já programados para executar determinados procedimentos. Elas são algoritmos que fazem um determinado procedimento. São caixas pretas onde colocamos um input e recebemos um output.\nPor exemplo, a função “sum” faz a soma de um conjunto de valores, como o “=SOMA( )” no Excel.\n\nsum(1,2)\n\n[1] 3\n\n\nEscrevemos o nome da função seguido de parênteses. Dentro dos parênteses inserimos os argumentos necessários, veja:\nfunção(atributo1 = isso, atributo2 = aquilo)\nVamos ver um exemplo.\n\n# 1 é maior do que 3? Se sim, retorne \"Verdade\", se não, \"Mentira\" \nifelse( test = 1&gt;3, yes = \"Verdade\", no =\"Mentira\" ) \n\n[1] \"Mentira\"\n\n\nVocê já está, intuitivamente, percebendo que a estrutura das funções no R é dada pelo nome da função (ex. “sum”), seguido de atributos inseridos dentro de parênteses “( atributos aqui )”. Nem todas as funções exigem atributos, mas todas as funções executam algum procedimento. Por exemplo, temos um conjunto de funções muito úteis para limpar a memória local (o que ajuda no processamento) e obter o diretório (pasta) principal onde estamos trabalhando.\n\ngc( ) : de “Garbage Clean”, para limpeza da lixeira e liberação de memória.\ngetwd( ) : de “Get Working Directory”, para obter diretório base no qual está trabalhando.\n\n\ngc()  \n\n          used (Mb) gc trigger (Mb) max used (Mb)\nNcells  599358 32.1    1359931 72.7  1359931 72.7\nVcells 1107076  8.5    8388608 64.0  1876245 14.4\n\ngetwd()\n\n[1] \"C:/Users/13477365/Documents/book-dadoscomr\"\n\n\nHá um conjunto extenso de funções de base do R, que já vem com o software na instalação. Existem especialmente funções para gestão de memória, armazenamento, dados e estatística. Além do R base, há também um universo de funções programadas pela comunidade de usuários em diversos domínios, como ciências ambientais, psicologia, economia e até funções criadas por sociólogos! Diferente das funções do R base, essas estão associadas a pacotes externos que devem ser instalados e carregados. Isso veremos na próxima aula, quando abordaremos o manuseio de dados.\n\n\nConstruindo um dado estruturado\nCom os comandos básicos que vimos anteriomente, vamos iniciar a construção de uma base de dados.\nVimos que um conjunto de valores de mesmo tipo/classe pode ser guardado em um vetor, armazenado na memória local como um objeto. Por definição, os vetores são represetados como colunas.\nQuando temos vetores de igual tamanho (com a mesma quantidade de valores), podemos uni-los em uma nova estrutura de dados, chamada data.frame. O data.frame é a famosa estrutura retangular de dados que conhecemos, com os casos nas linhas e variáveis nas colunas, como no survey tradicional. Portanto, para criar uma base de dados no R, basta ter os vetores e uni-los em um data.frame.\n\nnome &lt;- c(\"Carlos\",\"Maria\",\"Renata\",\"Cleber\",\"Joana\")\nidade &lt;- c(18,23,45,21,45)\nsexo  &lt;- c(\"M\",\"F\",\"F\",\"M\",\"F\")\nesquerda &lt;- c(T,F,T,F,T)\n\nmeus_dados &lt;- data.frame(nome,idade,sexo,esquerda)\nmeus_dados\n\n    nome idade sexo esquerda\n1 Carlos    18    M     TRUE\n2  Maria    23    F    FALSE\n3 Renata    45    F     TRUE\n4 Cleber    21    M    FALSE\n5  Joana    45    F     TRUE\n\n\nObserve que cada vetor contido na base de dados é de um tipo. Todo o tratamento e análise das variáveis depende disso, como veremos adiante.",
    "crumbs": [
      "Capítulo 1"
    ]
  },
  {
    "objectID": "class01.html#recaptulando",
    "href": "class01.html#recaptulando",
    "title": "Capítulo 1",
    "section": "Recaptulando",
    "text": "Recaptulando\nNeste capítulo, vimos que o R não é de comer, mas de praticar. Passamos pela sintaxe e pelos primeiros comandos fundamentais, que são a base para todas as operações nesta e em outras linguagens de programação. Vimos sobre as funções, como são estuturadas no R e como usá-las. Por fim, vimos como construir um data.frame a partir de vetores de igual tamanho e as relações lógicas entre valores.\nNa próxima aula, iniciaremos retomando as relações lógicas e veremos as relações condicionais. Faremos alguns exercícios usando elas para manusear dados e, depois, partiremos para o uso de pacotes para importar e manusear dados estruturados.\n\nExtra: Google Colab\nUma alternativa para trabalhar com o R é usar o ambiente virtual da Google: o Google Colaboratory ou simplesmente Colab. Para isso, basta fazer login com uma conta google e criar um notebook. Para trabalhar com o R, é necessário editar as configurações. Para isso, vá em editar &gt; configurações do notebook &gt; altere de Python 3 para R.\n\n\n\n\n\n\nFigure 3: Passo 01 - Google Colab\n\n\n\n\n\n\n\n\n\nFigure 4: Passo 2 - Google Colab\n\n\n\nDiferente do RStudio, o Google Colab possui apenas uma janela principal que intercala texto e blocos de códigos. O uso é bastante intuitivo, embora os recursos sejam limitados. Para obter maior capacidade de processamento e memória, é necessário pagar.",
    "crumbs": [
      "Capítulo 1"
    ]
  },
  {
    "objectID": "class01.html#entendi.-então-como-eu-uso",
    "href": "class01.html#entendi.-então-como-eu-uso",
    "title": "Capítulo 1",
    "section": "Entendi. Então como eu uso?",
    "text": "Entendi. Então como eu uso?\nComo vimos, o R é pa praticar! Então vamos colocar nossas ferramentas em mãos.\nÉ fudamental saber que o R é a linguagem, e o RStudio é o ambiente de desenvolvimento. Não adianta tentar usar o RStudio sem o R. Portanto, faça a instalação do R e RStudio de acordo com as especificações do seu computador.\nPara começar a usar o R, é preciso entender o que são e como funcionam as operações básicas. Toda linguagem de programação tem uma sintaxe e as mesmas operações básicas. Neste capítulo, veremos os comandos básicos para guardar valores na memória e manuseá-los, operações com vetores e data.frames (dados estruturados) e como usar funções e operações de lógica.\nComo uma experiência antropológica e de choque , abra o R (não o RStudio!). Caso tenha dificuldade em encontrar o software, digite na busca do seu computador apenas a letra “R” e procure em aplicativos.\nVocê deve abrir algo parecido com a janela da Figura 1.\n\n\n\n\n\n\nFigure 1: Console R\n\n\n\nA janela onde escrevemos as linhas de comandos executáveis chamamos de “console”. Abrindo o R diretamente, temos apenas a janela do console para inserir os comandos. Triste, né? Mas tudo fica mais sexy com o RStudio. Para fins didáticos, vamos continuar com o R base. Precisamos olhar um pouco para o console como faziam os egípcios e os hebreus.\nNeste livro, por ser escrito no R, temos as linhas de comando destacadas, que podem ser copiadas e coladas no console para executar.\n\nPrimeiro contato: R como calculadora\nExecutar cálculos simples com o R é uma forma mais amigável de começar entender como a linguagem funciona. Podemos pensar no computador como uma grande calculadora que computa operações e, no R, como um meio para comandar o computador.\nPor exemplo, no comando abaixo, eu computo um cálculo simples no R e, em seguida, recebo um resultado. Faça o mesmo no console do R base. Digite 1+2 e dê um enter para computar\n\n1+2\n\n[1] 3\n\n\nLegal, não é? Talvez não ainda. Mas vai ficar!\nAlém de números e cálculos, podemos executar outros tipos de informações como caracteres (texto) e valores lógicos (Verdadeiro e Falso). Para caracteres, devemos sempre utilizar aspas simples ou duplas, conforme a linha abaixo.\n\n\"Utilize sempre aspas para informações textuais\"\n\n[1] \"Utilize sempre aspas para informações textuais\"\n\n\nPara valores lógicos, usamos o inglês TRUE e FALSE, que podem ser abreviados pelas iniciais T e F, conforme a linha abaixo.\n\nTRUE\n\n[1] TRUE\n\nFALSE\n\n[1] FALSE\n\nT\n\n[1] TRUE\n\nF\n\n[1] FALSE\n\n\nCom o tempo, vamos escrevendo códigos (scripts) que compilam um conjunto sequencial de comandos. Os códigos vão ficando cada vez mais complexos na medida em que vamos trabalhando. Um recurso muito importante para torná-los interpretáveis para humanos são os comentários. Para que o R não interprete uma linha de um documento como um comando, devemos marcá-la com “#”. Toda informação que vem depois de um “#”, na linha, é descosiderada pelo R.\n\n# Este comentário não é executado. Simples assim.\n\nComo exercício, escreva um comentário e execute no console do R base. Depois escreva o mesmo sem a marcação de comentário.\nVocê vai perceber que, sem indicar que e um comentário (#), o R tenta computar os valores e retorna erro, porque não consegue identificar nada associado.\nEm geral, números, caracteres, valores lógicos e comentários compõem a base fundamental da linguagem R.\nVamos fazer um exercício didático para introduzir o uso de códigos. Copie as linhas de comando abaixo e cole na janela console, no R base. Você pode ir colando linha a linha e executado os comandos para observar o que acontece.\n\n# Primeiro código com o R\n# Autor: Victor G Alcantara\n\n# R como calculadora\n\n## Fazedo cálculos simples\n1+2\n\n3+5*4\n\n10/2\n\n## Computando texto\n\"Trabalhar com programação é desafiador\"\n\n## Computado valores lógicos\nTRUE\n\nFALSE\n\nUma vez compreedendo as bases, podemos operá-las utilizando a memória do computador.\nPara guardar valores na memória, como objetos, utilizamos os sinais se atribuição “&lt;-” e “=”.\n\nSinais de atribuição de valores à memória:\n\nSeta: objeto &lt;- valor\nUm igual: objeto = valor\n\n\n\nresultado &lt;- 1+2\n\nresultado\n\n[1] 3\n\n\nNo exemplo acima, guardamos o cálculo 1+2 no objeto “resultado”, armazenado na memória. Perceba que estamos interpretando a linha de código. O que o R interpreta é o mesmo. Podemos ler como: atribua ao objeto “resultado” o valor da conta 1+2.\nUma vez guardado na memória, podemos nos referir ao objeto para acessar o valor, conforme ilustra o exemplo abaixo.\n\nresultado + 1\n\n[1] 4\n\n\nPara guardar mais de um valor em um objeto, devemos utilizar uma função para concatenar os valores, expressa por um “c” seguido de parêteses e os valores contidos, separados por vírgula.\n\nvalores_num &lt;- c(1,2,3,4,5)\n\nvalores_num\n\n[1] 1 2 3 4 5\n\n\nPodemos fazer operações com todos os valores guardados em um objeto. Por definição, chamamos um objeto que contenha apenas um tipo ou classe de valores como um vetor. Podemos dizer, assim, que criamos um vetor guardado no objeto “valores_num” que recebe os valores de 1 a 5.\nPodemos fazer operações com nosso vetor, como no exemplo abaixo.\n\n1 + valores_num\n\n[1] 2 3 4 5 6\n\n\nToda vez que nos referirmos ao nome do objeto guardado, sem o uso de aspas, o R vai entender que estamos nos referindo a todos os valores guardados no vetor. Por isso a soma 1 + vetor tem como resultado todos os valores + 1.\nPara acessar um valor específico em um vetor, podemos indicar a localização do valor utilizando colchetes [ ].\nvetor[ posição do valor ]\n\nvalores_num[3] # Obtendo o valor guardado na posição 3\n\n[1] 3\n\n\nUm vetor guarda sempre um tipo ou classe de valores. Podemos fazer operações que sejam adequadas a cada tipo de valor contido. Por exemplo, para vetores que guardam textos, não podemos fazer cálculos (o R retornará como erro).\n\nvalores_chr &lt;- c(\"A\",\"B\",\"C\",\"D\",\"E\")\nvalores_chr\n\n[1] \"A\" \"B\" \"C\" \"D\" \"E\"\n\nvalores_chr[1] # Obtendo o valor guardado na posição 1\n\n[1] \"A\"\n\nvalores_chr[3] # Obtendo o valor guardado na posição 3\n\n[1] \"C\"\n\n\n\nvalores_chr + 1\n\nError in valores_chr + 1: argumento não-numérico para operador binário\n\n\nNão se assuste com a mensagem de erro. Ela sempre aparecerá com alguma explicação que te ajudará a entender. Neste caso, ele está dizendo que o argumento não é um valor numérico para fazer cálculo. O R se esforça para ser nosso amigo e muitas vezes, quando notar que pode ter algo errado, vai nos avisar com Warning.\nEmbora tente ser nosso amigo, ele pode te frustrar com a quantidade de problemas e erros que aparecerão no seu caminho. Mas nunca se esqueça de que o R é burro e o inteligente é você.\nAté aqui vimos o suficiente do R base. Agora, precisamos do RStudio para avançar de uma forma mais atrativa.\n\n\nExplorado comandos com RStudio\nAbra o RStudio no seu computador.\nVocê deve abrir algo parecido com a Figura 2. Uma das inovações deste ambiente de trabalho é dividir o fluxo em quatro janelas: 1) script; 2) console; 3) gestão de aquivos e outputs e; 4) ambiente global (gestão de memória).\n\n\n\n\n\n\nFigure 2: RStudio Layout\n\n\n\n\n\n\nEditor de Scripts: Essa janela é sua amiga da organização! É onde você escreve e salva seu código em arquivos. Em vez de rodar cada comando diretamente, você pode escrever vários comandos e depois executá-los da forma que quiser, selecionando partes ou tudo, quando estiver pronto.\n\n\n\n\nConsole: É onde a mágica acontece! É a mesma janela que abrimos no R base. Aqui você executa comandos e vê os resultados imediatamente. Pense nele como uma “calculadora” poderosa: basta digitar o código, apertar Enter, e o R responde!\n\n\n\n\nFiles/Plots/Packages/Help: Essa janela multifuncional é super versátil. No Files, você navega nos arquivos do projeto; em Plots, visualiza gráficos; em Packages, gerencia as bibliotecas instaladas; e em Help, encontra ajuda para funções e pacotes. É um verdadeiro canivete suíço para explorar recursos e referências do R!\n\n\n\n\nAmbiente/Histórico: Aqui fica o “quadro de controle” dos seus dados e variáveis. No Ambiente, você vê todas as variáveis e dados carregados na sessão, enquanto o Histórico mostra os comandos que você já executou. Se você quiser repetir ou ajustar um comando anterior, é só buscá-lo aqui.\n\n\n\nAgora, com o RStudio, registraremos nossos códigos no editor de script. Caso já não tenha um script R aberto, isto é, não esteja aparecedo a tela 1 do editor de script, crie uma nova no botão “+”, localizado no canto superior esquerdo da tela. Perceba que podemos criar diversos tipos de arquivos para edição. O RStudio comporta, inclusive, arquivos para serem executados em outras linguagens, como Python, C++ e SQL.\nSeguindo a sintaxe da linguagem e as funções disponíveis, escrevemos nossos códigos no editor de script. Em nosso curso, veremos comandos e funções importantes para importação, tratamento, manuseio e análise de dados. Mas para um bom domínio da ferramenta, é importante entendermos os fundamentos de como ela opera.\nPor convenção, seguimos padrões de escrita do código, que chamamos de identação. A identação auxilia a deixar o código organizado e interpretável para humanos. Isso mesmo que você entendeu, identação é simplesmente uma foma convencional de organizar a escrita dos códigos. Mesmo os softwares de desenvolvimento, como o RStudio, são capazes de interpretar padrões de identação. Por exemplo, quando iserimos um comentário com “#” e finalizamos com traços “—-”, o RStudio entende que se trata de um título para um segmento do código. Veremos como fazer isso mais pra frente.\nEm geral, orgaizamos os códigos seguindo a lógica do fluxo de trabalho. Que pode ser descrito por:\n\nSetup e configurações básicas\nArmazenamento e importação de dados\nManuseio de dados\nAnálise de dados\nExportação dos resultados\n\nAgora, vamos retomar os fundamentos da linguagem R em um script organizado usando o RStudio.\n\n\nFunções\nAlém dos comandos básicos, podemos também usar funções, que são comandos já programados para executar determinados procedimentos. Elas são algoritmos que fazem um determinado procedimento. São caixas pretas onde colocamos um input e recebemos um output.\nA estrutura das funções no R é a seguinte: escrevemos o nome da função, seguido de parênteses dentro dos quais vão os argumentos de entrada (inputs).\nfunção ( argumento 1 = isso, argumento 2 = aquilo )\nPor exemplo, a função “sum” faz a soma de um conjunto de valores, como o “=SOMA( )” no Excel.\n\nsum(1,2)\n\n[1] 3\n\n\nAlgumas operações de cálculo também são codificadas como funções no R. É o caso de módulo para extrair valores absolutos e da raíz quadrada, por exemplo.\n\nabs(-4) # Função abs para extrair valores absolutos\n\n[1] 4\n\nsqrt(4) # Função sqrt (Square Root) para extrair raíz quadrada\n\n[1] 2\n\n\nComo demonstrado acima, a estrutura das funções no R é dada pelo nome da função (ex. “sum”), seguido de argumentos inseridos dentro de parênteses “( argumentos aqui )”. Nem todas as funções exigem argumentos, mas todas as funções executam algum procedimento. Por exemplo, temos um conjunto de funções muito úteis para limpar a memória local (o que ajuda no processamento) e obter o diretório (pasta) principal onde estamos trabalhando.\n\ngc( ) : de “Garbage Clean”, para limpeza da lixeira e liberação de memória.\ngetwd( ) : de “Get Working Directory”, para obter diretório base no qual está trabalhando.\n\n\ngc()  \n\n          used (Mb) gc trigger (Mb) max used (Mb)\nNcells  599832 32.1    1360454 72.7  1360454 72.7\nVcells 1112024  8.5    8388608 64.0  1876245 14.4\n\ngetwd()\n\n[1] \"C:/Users/13477365/Documents/book-dadoscomr\"\n\n\nHá um conjunto extenso de funções de base do R, que já vem com o software na instalação. Existem especialmente funções para gestão de memória, armazenamento, dados e estatística. Além do R base, há também um universo de funções programadas pela comunidade de usuários em diversos domínios, como ciências ambientais, psicologia, economia e até funções criadas por sociólogos! Diferente das funções do R base, essas estão associadas a pacotes externos que devem ser instalados e carregados. Isso veremos na próxima aula, quando abordaremos o manuseio de dados.\n\n\nData.frame: dado estruturado\nCom os comandos básicos que vimos anteriomente, vamos iniciar a construção de uma base de dados.\nVimos que um conjunto de valores de mesmo tipo/classe pode ser guardado em um vetor, armazenado na memória local como um objeto. Por definição, os vetores são represetados como colunas.\nTemos um conjunto de funções úteis no manuseio de objetos, para saber o tamanho e o tipo/classe.\n\nclass( ) ou typeof( ) : funções para verificar o tipo de objeto\nlenght( ) : função para verificar o tamanho do objeto\n\n\n# Vetor de nomes, do tipo caracteres (chr)\nnome &lt;- c(\"Carlos\",\"Maria\",\"Renata\",\"Cleber\",\"Joana\")\n\n# Vetor de idade, do tipo numérico (num)\nidade &lt;- c(18,14,45,16,33)\n\n# Vetor de posicionamento político à esquerda, do tipo lógico\nesquerda &lt;- c(T,F,T,F,T)\n\n# verificando o tipo/classe dos vetores\nclass(nome)\n\n[1] \"character\"\n\nclass(idade)\n\n[1] \"numeric\"\n\nclass(esquerda)\n\n[1] \"logical\"\n\n# verificando tamanho dos vetores\nlength(nome)\n\n[1] 5\n\nlength(idade)\n\n[1] 5\n\nlength(esquerda)\n\n[1] 5\n\n\nConforme veremos a seguir, essas funções valem também para outros tipos de objeto, como o data.frame.\nQuando temos vetores de igual tamanho (com a mesma quantidade de valores), podemos uni-los em uma nova estrutura de dados, chamada data.frame. O data.frame é a famosa estrutura retangular de dados que conhecemos, com os casos nas linhas e variáveis nas colunas, como no survey tradicional. Portanto, para criar uma base de dados no R, basta ter os vetores de igual tamanho e uni-los em um data.frame.\n\n# Construindo base de dados com vetores de igual tamanho\nmeus_dados &lt;- data.frame(nome,idade,esquerda)\n\nclass(meus_dados)\n\n[1] \"data.frame\"\n\nmeus_dados\n\n    nome idade esquerda\n1 Carlos    18     TRUE\n2  Maria    14    FALSE\n3 Renata    45     TRUE\n4 Cleber    16    FALSE\n5  Joana    33     TRUE\n\n\nObserve que cada vetor contido na base de dados é de um tipo. Todo o tratamento e análise das variáveis depende disso, como veremos adiante.\nQuando tratamos de vetores, vimos que para acessar os valores contidos era peciso usar colchetes e o endereço do valor. Agora, com data.frame/dados estruturados, precisamos indicar duas entradas para localizar o valor [ linha , coluna ].\n\n# Localizando o terceiro valor do vetor \"nome\"\nnome[3]\n\n[1] \"Renata\"\n\n# Localizando o nome \"Renata\" na base estruturada\nmeus_dados[3,1] # Linha = 3, Coluna = 1\n\n[1] \"Renata\"\n\n\nQuando não inserimos nada, o R entende que não estamos especificando a localização e, assim, queremos tudo.\n\nmeus_dados[,] # Todos os valores em todas as colunas\n\n    nome idade esquerda\n1 Carlos    18     TRUE\n2  Maria    14    FALSE\n3 Renata    45     TRUE\n4 Cleber    16    FALSE\n5  Joana    33     TRUE\n\nmeus_dados[,2] # Todos os valores da coluna 2\n\n[1] 18 14 45 16 33\n\nmeus_dados[3,] # Todos os valores na linha 3\n\n    nome idade esquerda\n3 Renata    45     TRUE\n\n\nPodemos também localizar mais de um valor, inserindo o conjunto específico de localização.\n\nmeus_dados[ c(1,3) , 1 ]\n\n[1] \"Carlos\" \"Renata\"\n\n\nHá também outro método para localizar valores em data.frame, usando o cifrão ($). Quando inserimos o nome do objeto onde está guardada a nossa base de dados, podemos utilizar o cifrão para indicar a coluna que queremos acessar, como no exemplo a seguir.\n\nmeus_dados$nome\n\n[1] \"Carlos\" \"Maria\"  \"Renata\" \"Cleber\" \"Joana\" \n\n\nMuitas vezes é mais prático manusear as variáveis usando a localização pelo cifrão. Podemos também combinar o cifrão com o colchetes, como a seguir:\n\nmeus_dados$nome[2]\n\n[1] \"Maria\"\n\n\nEsses são os métodos para localizar e selecionar valores com o R base. Mais a frente, veremos formas mais intuitivas de fazer isso. Mas é fundamental saber a base, porque todo o resto vem daqui.\n\n\nRelações lógicas\nAgora que vimos o fundamento dos vetores e a construção de uma base de dados, vamos fechar este capítulo com um último tópico de fundamentos: as relações lógicas.\nPodemos relacionar dois valores em testes lógicos que retornam um resultado. São quatro as formas principais de teste lógico:\n\nSe algo é maior que outro, usando o símbolo ” &gt; ”\nSe algo é menor que outro, usando o símbolo ” &lt; ”\nSe algo é igual a outro, usando ” == ”\nSe algo é diferente de outro, usando ” != ”\nSe algo está contido em outro, usando %in%\nSe algo não está contido em outro, usando a exclamação (!) com o %in% (isso não é tão simples, veja a estrutura nos exemplos)\n\nTambém podemos combinar as relações com:\n\nMaior ou igual “&gt;=”\nMenor ou igual “&lt;=”\n\n\n# Relações lógicas são operações em que testamos uma sentença tendo como resultado: TRUE (T) ou FALSE (F)\n\n2 &gt;  2  # MAIOR QUE\n\n[1] FALSE\n\n2 &lt; 2   # MENOR QUE\n\n[1] FALSE\n\n2 == 2  # IGUALDADE\n\n[1] TRUE\n\n2 &gt;= 2 # MAIOR OU IGUAL\n\n[1] TRUE\n\n\"eu\" == \"todo mundo\" # Igualdade\n\n[1] FALSE\n\n\"eu\" == \"eu\"\n\n[1] TRUE\n\n\"eu\" != \"vc\"         # Diferença\n\n[1] TRUE\n\n# Por quê igualdade são dois sinais?\n# R: Porque apenas um significa atribuição de valor. Igual a setinha.\n\n# Teste em grupo\n\"eu\" %in% c(\"vc\",\"todo mundo\") # Generalização - se contém\n\n[1] FALSE\n\n# Nota importante: \"!\" opera como um sinal de negação/diferença\n\n!( \"eu\" %in% c(\"vc\",\"todo mundo\") )\n\n[1] TRUE\n\n\nAs relações lógicas são fundamentos da programação e podemos usar em muitos comandos. Por exemplo, para filtrar e selecionar nosso banco de dados. Antes de entrar nesses procedimetos, vamos usar fazer alguns testes lógicos usando nosso banco de dados. Tente ler e interpretar os seguintes testes:\n\nmeus_dados[ 1 , 2 ] &gt;= meus_dados[ 5 , 2 ]\n\n[1] FALSE\n\n# Leitura: o valor da linha 1, coluna 2 é maior ou igual ao valor da linha 5, coluna 2?\n\n\nmeus_dados[  , 2 ] &gt;= 18\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE\n\n# Leitura: os conjunto de valores da coluna 2 (idade) é maior ou igual a 18?\n\nAgora, usaremos o resultado do teste lógico para filtrar os casos da nossa base de dados. Primeiro, é preciso guardar o resultado do teste lógico em um objeto.\n\nmaior_ou_igual_18 &lt;- meus_dados[  , 2 ] &gt;= 18\nmaior_ou_igual_18\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE\n\n\nAgora, utilizaremos os valores para filtrar os casos nas linhas. Quando o valor lógico é igual à TRUE, o R retorna o valor, quando é FALSE, não retorna.\n\n# Exemplo antes de complexificar\nmeus_dados[ c(F,F,T,F,F) , ]\n\n    nome idade esquerda\n3 Renata    45     TRUE\n\n# No exemplo acima, indicamos somente o terceiro valor como TRUE, para filtrar.\n\nmeus_dados[ maior_ou_igual_18 , ]\n\n    nome idade esquerda\n1 Carlos    18     TRUE\n3 Renata    45     TRUE\n5  Joana    33     TRUE\n\n\nNão se assuste com o uso da lógica para manusear os dados. Mais a frente, veremos caminhos para executar esses comandos de uma forma mais amigável e intuitiva, seguindo os passos do projeto tidy data do Hadley Wickham, especialmente o princípio de escrita de códigos interpretáveis para humanos.\n\n\nExtra: Google Colab\nUma alternativa para trabalhar com o R é usar o ambiente virtual da Google: o Google Colaboratory ou simplesmente Colab. Para isso, basta fazer login com uma conta google e criar um notebook. Para trabalhar com o R, é necessário editar as configurações. Para isso, vá em editar &gt; configurações do notebook &gt; altere de Python 3 para R.\n\n\n\n\n\n\nFigure 3: Passo 01 - Google Colab\n\n\n\n\n\n\n\n\n\nFigure 4: Passo 2 - Google Colab\n\n\n\nDiferente do RStudio, o Google Colab possui apenas uma janela principal que intercala texto e blocos de códigos. O uso é bastante intuitivo, embora os recursos sejam limitados. Para obter maior capacidade de processamento e memória, é necessário pagar.",
    "crumbs": [
      "Capítulo 1"
    ]
  },
  {
    "objectID": "class01.html#desafio",
    "href": "class01.html#desafio",
    "title": "Capítulo 1",
    "section": "Desafio",
    "text": "Desafio\nUtilizado o RStudio ou Google Colab, exercite os conhecimentos tratados neste capítulo no desafio a seguir.\n\n# Desafio ----\n# Autor: Seu nome aqui\n\n# 1. Crie três objetos que guardam vetores com valores \n# de tipos diferentes (numérico, caracteres e lógicos)\n\n# 2. Verifique se os vetores têm a mesma quantidade de valores\n\n# 3. Crie um data.frame/base de dados com os vetores\n\n# 4. Localize o valor guardado na posição \n# seus_dados[2,1] : segunda linha e terceira coluna\n\n# 5. Faça um teste lógico para verificar se o primeiro valor do vetor\n# numérico é maior ou igual ao último valor do vetor numérico da sua\n# base de dados\n\n\n\n\n\n[1] IHAKA, R.; GENTLEMAN, R. R: A Language for Data Analysis and Graphics. Journal of Computational and Graphical Statistics, v. 5, n. 3, p. 299, Sep. 1996. \n\n\n[2] WICKHAM, H. Tidy data. Journal of Statistical Software, v. 59, n. 10, p. 1–23, 2014. \n\n\n[3] BARBOSA, R. J. et al. Ciências sociais, censo e informação quantitativa no Brasil: entrevista com Elza Berquó e Nelson do Valle Silva. Novos Estudos - CEBRAP, n. 95, p. 143–155, Mar. 2013.",
    "crumbs": [
      "Capítulo 1"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referências",
    "section": "",
    "text": "[1] IHAKA, R.; GENTLEMAN, R. R: A\nLanguage for Data Analysis and\nGraphics. Journal of Computational and\nGraphical Statistics, v. 5, n. 3, p. 299, set. 1996. \n\n\n[2] WICKHAM, H. Tidy Data.\nJournal of Statistical Software, v. 59, n. 10, p. 1–23,\n2014. \n\n\n[3] WICKHAM, H.; GROLEMUND, G.; ÇETINKAYA-RUNDEL,\nM. R for Data\nScience. 2. ed. [s.l.] O’Reilly, 2024.",
    "crumbs": [
      "Referências"
    ]
  },
  {
    "objectID": "class02.html#funções-uma-ideia-mais-detalhada",
    "href": "class02.html#funções-uma-ideia-mais-detalhada",
    "title": "Capítulo 2",
    "section": "",
    "text": "install.packages( ) : função para instalar pacotes distribuídos pelo CRAN\n\n\n\nlibrary( ) : função para carregar na memóroia os pacotes instalados no computador",
    "crumbs": [
      "Capítulo 2"
    ]
  },
  {
    "objectID": "class02.html#select-e-filter",
    "href": "class02.html#select-e-filter",
    "title": "Capítulo 2",
    "section": "Select e Filter",
    "text": "Select e Filter\nComo vimos anteriormente, podemos filtrar e selecionar nossa base usando apenas comandos básicos do R.\n\n# Selecionar variáveis\nminha_selecao_dados &lt;- br_uf_data[,c(1,9)]\nhead(minha_selecao_dados)\n\n  sigla_uf indice_gini\n1       AC        0.63\n2       AL        0.63\n3       AM        0.65\n4       AP        0.60\n5       BA        0.62\n6       CE        0.61\n\n# Filtrar casos \nmeu_filtro_casos &lt;- br_uf_data[ , 9 ] &gt; 0.60\nmeu_filtro_casos &lt;- br_uf_data[ meu_filtro_casos, 1 ]\n\nhead(meu_filtro_casos)\n\n[1] \"AC\" \"AL\" \"AM\" \"BA\" \"CE\" \"DF\"\n\n\nPara tornar nosso código mais interpretável e organizado, vamos utilizar as funções do pacote tidyverse para operações de manuseio dos dados. Veja como tudo fica mais simples.\n\nselect( ) : função para selecionar colunas/variáveis\nfilter( ): função para filtrar casos\n\n\n# Selecionar variáveis\nminha_selecao_dados &lt;- select(\n  .data = br_uf_data,\n  sigla_uf,renda_pc)\nhead(minha_selecao_dados)\n\n  sigla_uf renda_pc\n1       AC   522.15\n2       AL   432.56\n3       AM   539.80\n4       AP   598.98\n5       BA   496.73\n6       CE   460.63\n\nmeu_filtro_casos &lt;- filter(\n  .data = br_uf_data,\n  indice_gini &gt; 0.60)\nhead(meu_filtro_casos)\n\n  sigla_uf populacao populacao_urbana renda_pc     pea      pia\n1       AC    733559           532279   522.15  304651   573909\n2       AL   3120494          2297860   432.56 1261201  2547711\n3       AM   3483985          2755490   539.80 1473043  2728336\n4       BA  14016906         10102476   496.73 6581418 11764109\n5       CE   8452381          6346557   460.63 3657038  7111302\n6       DF   2570160          2482210  1715.11 1408410  2180903\n  expectativa_vida taxa_superior_25_mais indice_gini prop_renda_10_ricos\n1            71.63                  8.98        0.63               50.56\n2            70.32                  6.90        0.63               51.76\n3            73.30                  8.23        0.65               53.64\n4            71.97                  6.40        0.62               51.05\n5            72.60                  7.16        0.61               50.76\n6            77.35                 23.95        0.63               49.26\n  prop_renda_40_pobres\n1                 6.89\n2                 7.62\n3                 6.40\n4                 7.86\n5                 8.13\n6                 6.98\n\n\nAgora, para continuar trabalhando com esses dados, vamos fazer uma seleção de variáveis e um filtro de casos conforme nossos interesses.\nPara isso, vamos introduzir o uso do pipe, uma estrutura de código muito útil na programação. O pipe é composto pelo símbolo %&gt;%, e representa a ideia de que um objeto é tomado como referêcia para a próxima função a ser utilizada.\n\nbr_uf_data &lt;- br_uf_data %&gt;% select(sigla_uf,\n                                    populacao,populacao_urbana,renda_pc,\n                                    pea,pia,expectativa_vida,taxa_superior_25_mais,\n                                    indice_gini,prop_renda_10_ricos,\n                                    prop_renda_40_pobres)\n\n# Filtro para escolas que tiveram mais de 80% (0.8) dos estudantes matriculados participando da prova\nbr_uf_data &lt;- br_uf_data %&gt;% filter(indice_gini &gt;= 0)",
    "crumbs": [
      "Capítulo 2"
    ]
  },
  {
    "objectID": "class02.html#rename",
    "href": "class02.html#rename",
    "title": "Capítulo 2",
    "section": "Rename",
    "text": "Rename\nDepois de filtrada e selecionada a nossa base de dados, podemos renomear nossas variáveis para deixá-la mais intuitiva. Muitas vezes elas estão codificadas e dificultam a interpretação e manuseio. Para isso, utilizaremos a função rename.\n\nrename( ): para renomear colunas/variáveis\n\n\nbr_uf_data &lt;- br_uf_data %&gt;% rename(\n                          uf=sigla_uf,\n                          pop=populacao,\n                          pop_urb=populacao_urbana,\n                          rpct=renda_pc,\n                          exp_vida=expectativa_vida,\n                          tx_sup=taxa_superior_25_mais,\n                          gini=indice_gini)\n\nhead(br_uf_data)\n\n  uf      pop  pop_urb   rpct     pea      pia exp_vida tx_sup gini\n1 AC   733559   532279 522.15  304651   573909    71.63   8.98 0.63\n2 AL  3120494  2297860 432.56 1261201  2547711    70.32   6.90 0.63\n3 AM  3483985  2755490 539.80 1473043  2728336    73.30   8.23 0.65\n4 AP   669526   601036 598.98  297107   526975    73.80  10.84 0.60\n5 BA 14016906 10102476 496.73 6581418 11764109    71.97   6.40 0.62\n6 CE  8452381  6346557 460.63 3657038  7111302    72.60   7.16 0.61\n  prop_renda_10_ricos prop_renda_40_pobres\n1               50.56                 6.89\n2               51.76                 7.62\n3               53.64                 6.40\n4               47.44                 7.88\n5               51.05                 7.86\n6               50.76                 8.13",
    "crumbs": [
      "Capítulo 2"
    ]
  },
  {
    "objectID": "class02.html#export",
    "href": "class02.html#export",
    "title": "Capítulo 2",
    "section": "Export",
    "text": "Export\nTendo selecionado e filtrado os dados, podemos salvar o recorte da base original em um novo arquivo, para continuar o manuseio no próximo capítulo. Para isso, usamos a função export do pacote Rio.\n\nexport( ) : para exportar dados do R\n\nAssim como a função import, basta inserir o endereço do diretório e, no final, o nome do arquivo com a extensão desejada para salvar. O pacote rio comporta as extensões mais utilizadas (excel - xlsx, spss - sav, comma separated values - csv, etc.).\n\nexport(x = br_uf_data,\n       file = \"G:/Meu Drive/02 - GitHub/R-Intro/A02 - Explore II/0 - data/mydata.RDS\")",
    "crumbs": [
      "Capítulo 2"
    ]
  },
  {
    "objectID": "class02.html#import",
    "href": "class02.html#import",
    "title": "Capítulo 2",
    "section": "Import",
    "text": "Import\nOs primeiros pacotes que vamos utilizar é o Rio (R Input Output) e o Tidyverse.\n\n# Título do script: Como iniciar um script\n# Autor: Victor G Alcantara\n\n# Setup -------------------------------------------------------\n\n# Gestão da memória\nrm( list = ls() ) # Remove todos os objetos listados na memória\ngc() # Faz a limpeza da lixeira da memória\n\n          used (Mb) gc trigger  (Mb) max used (Mb)\nNcells  965752 51.6    1906154 101.8  1362645 72.8\nVcells 1669242 12.8    8388608  64.0  2288537 17.5\n\n# Gestão de funções e pacotes\n#install.packages(\"tidyverse\") # Instala o pacote tidyverse como exemplo\n#install.packages(\"rio\") # R Input Output,  para impotar e exportar dados\n\nlibrary(rio)\nlibrary(tidyverse)\n\n# Gestão do diretório\ngetwd() # Verifica diretório principal de trabalho\n\n[1] \"C:/Users/13477365/Documents/book-dadoscomr\"\n\nsetwd(dir = \"C:/Users/13477365/Documents/book-dadoscomr\") # Define diretório principal de trabalho\n# Atenção à posição das barras! Deve estar como \"/\"\n\nAgora, vamos importar nosso primeiro dado de trabalho.\n\n# Import ---------------------------------------------------\n\nbr_uf_data &lt;- import( \"G:/Meu Drive/02 - GitHub/R-Intro/000 - P&R/00 data/br_uf.csv\" )\n\nObserve que defini o encoding do arquivo como “Latin-1”, para identificar os acentos usados em línguas latinas como o português.\nCom os dados importados para a memória, podemos explorar as funções fundamentais no tratamento de dados.\nEm primeiro lugar, temos um conjunto de funções muito úteis para olhar para a estrutura dos dados. Diferente do SPSS e Excel, quando importamos um conjunto de dados e guardamos em um objeto, eles ficam armazenados na memória de modo que não observamos diretamente. É possível abrir a planilha de dados, mas não é recomendado quando os dados possuem larga escala, pois consome muito do processamento do computador. Por isso, utilizamos funções para verificar a estrutura dos nossos dados.\n\ndim( ): retorna as dimensões da base de dados (linhas x colunas)\nhead( ): retorna os primeiros valores da base de dados (default = 5, mas passível de alteração)\ntail( ): retorna os últimos valores da base de dados (default = 5, mas passível de alteração)\nnames( ): retorna o nome das colunas/variáveis\nstr( ): retorna a estrutura da base de dados, indicando as dimensões e o tipo de cada variável\n\n\ndim( br_uf_data )\n\n[1] 27 11\n\n# O Saeb 2021 tem 70.897 linhas e 137 colunas\n\nnames( br_uf_data )\n\n [1] \"sigla_uf\"              \"populacao\"             \"populacao_urbana\"     \n [4] \"renda_pc\"              \"pea\"                   \"pia\"                  \n [7] \"expectativa_vida\"      \"taxa_superior_25_mais\" \"indice_gini\"          \n[10] \"prop_renda_10_ricos\"   \"prop_renda_40_pobres\" \n\n\n\nhead( br_uf_data , n = 3)\n\n  sigla_uf populacao populacao_urbana renda_pc     pea     pia expectativa_vida\n1       AC    733559           532279   522.15  304651  573909            71.63\n2       AL   3120494          2297860   432.56 1261201 2547711            70.32\n3       AM   3483985          2755490   539.80 1473043 2728336            73.30\n  taxa_superior_25_mais indice_gini prop_renda_10_ricos prop_renda_40_pobres\n1                  8.98        0.63               50.56                 6.89\n2                  6.90        0.63               51.76                 7.62\n3                  8.23        0.65               53.64                 6.40\n\nstr( br_uf_data )\n\n'data.frame':   27 obs. of  11 variables:\n $ sigla_uf             : chr  \"AC\" \"AL\" \"AM\" \"AP\" ...\n $ populacao            : int  733559 3120494 3483985 669526 14016906 8452381 2570160 3514952 6003788 6574789 ...\n $ populacao_urbana     : int  532279 2297860 2755490 601036 10102476 6346557 2482210 2931472 5420714 4147149 ...\n $ renda_pc             : num  522 433 540 599 497 ...\n $ pea                  : int  304651 1261201 1473043 297107 6581418 3657038 1408410 1832872 3168725 2594571 ...\n $ pia                  : int  573909 2547711 2728336 526975 11764109 7111302 2180903 3005851 5092674 5264736 ...\n $ expectativa_vida     : num  71.6 70.3 73.3 73.8 72 ...\n $ taxa_superior_25_mais: num  8.98 6.9 8.23 10.84 6.4 ...\n $ indice_gini          : num  0.63 0.63 0.65 0.6 0.62 0.61 0.63 0.56 0.55 0.62 ...\n $ prop_renda_10_ricos  : num  50.6 51.8 53.6 47.4 51 ...\n $ prop_renda_40_pobres : num  6.89 7.62 6.4 7.88 7.86 ...\n\n\nEmbora não seja recomendado olhar para a planilha de dados quando o volume é muito grande, podemos utilizar recursos para observar apenas uma parte dos dados.\n\nView( head( br_uf_data ) )\n\nApós observar a estrutura dos dados, temos uma ideia de quais variáveis e casos a base de dados guarda.\nAgora, podemos partir para o manuseio dos dados.",
    "crumbs": [
      "Capítulo 2"
    ]
  }
]